{"meta":{"title":"暮爱深秋","subtitle":"新手程序员的成长史","description":"我的目标是星辰大海","author":"康发伟","url":"http://kfw5264.github.io","root":"/"},"pages":[],"posts":[{"title":"Java对象初始化与清理","slug":"Java对象初始化与清理","date":"2020-08-23T06:33:36.000Z","updated":"2020-08-23T06:36:31.358Z","comments":true,"path":"2020/08/23/Java对象初始化与清理/","link":"","permalink":"http://kfw5264.github.io/2020/08/23/Java%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/","excerpt":"","text":"关于对象初始化 Java沿用C++中通过给一个类提供构造器来初始化对象。 构造器方法的名称与类名称一致，可以让调用者明确知道使用的是什么类型的对象，同时可以避免该方法与其成员方法名称一致。 Java创建一个类至少需要提供一个构造器方法以供该类型的对象初始化。 如果一个类不存在构造方法，那么Java会默认为其创建一个无参的构造器以供该类对象的初始化。 如果手动为一个类创建构造方法，那么Java将不会提供默认构造器，初始化的时候只能使用创建的构造器。 构造器可以通过参数不同来重载，调用者可以根据不同情况调用不同的构造器来初始化对象。 1234567891011121314151617181920212223242526272829// 不手动创建构造器，Java默认生成一个无参构造器public class Demo1 &#123; public void doSomething() &#123; // do something... &#125;&#125;// 手动创建构造器class Demo2 &#123; // 构造器1 public Demo2(int i) &#123; // do something &#125; // 构造器2 public Demo2(int i, Sting str) &#123; // do something &#125; public void doSomething() &#123; // do something... &#125;&#125;class App &#123; public static void main(String[] args) &#123; Demo1 demo1 = new Demo1(); // 调用Demo1的默认构造器初始化 // Demo2 demo21 = new Demo2(); // 编译不通过，Cannot resolve constructor &#x27;Demo()&#x27; Demo2 demo22 = new Demo2(1); // 调用Demo2(int i)的构造器 Demo2 demo23 = new Demo2(1, &quot;a&quot;); // 调用Demo2(int i, String str)的构造器 &#125;&#125; 关于方法重载 中国美食千千万，平常我在家喜欢自己做一些菜：比如红烧肉、麻婆豆腐、糖醋里脊……我们可以根据不同的食材，不同的调料来烹制出不同的美食。方法重载恰恰就类似我们平时的做饭，老婆扔给你一堆食材让你去做饭，也没有具体说让你做什么饭，但是你可以根据你老婆给你的食材来确定做什么饭，需要执行什么样的流程。 对于方法来说就是有统一的方法名，Java会根据你在调用这个方法的时候传入的参数来确定你是要执行哪一个方法。 每个重载方法都必须有一个独一无二的参数列表。 一般情况下尽量不要通过参数顺序来区分重载方法，因为这样会导致代码混乱。而且调用者不知情的情况下容易出错。 基本类型可以从一个较小的类型自动提升到一个较大的类型，这时候发生重载可能会造成一些混淆。 由于有时候仅仅只会调用方法而不接受其返回值，所以不可以通过返回值来区分重载。 12345678910111213141516171819202122232425262728293031323334public class Demo &#123; public void print(byte b) &#123; System.out.println(&quot;byte--&quot;+b); &#125; public void print(short s) &#123; System.out.println(&quot;short--&quot;+s); &#125; public void print(int i) &#123; System.out.println(&quot;int--&quot;+i); &#125; // print(int)&#x27; is already defined in xxx.Demo // 由于int类型参数的重载方法在上面已经定义，如果再次写一个int类型的重载方法编译不通过 /* public void print(int j) &#123; System.out.println(&quot;int--&quot;+j); &#125;*/ public void print(long l) &#123; System.out.println(&quot;long--&quot;+l); &#125; public static void main(String[] args) &#123; Demo demo = new Demo(); byte b = 6; demo.print(b); // byte--6 short s = 5; demo.print(5); // int--5 // short类型的参数会调用int类型的方法 int i = 12; demo.print(i); // int--12 long l = 1; demo.print(l); // long--1 &#125;&#125; 关于this关键字在Java中，this一般是用在类的内部，表示的是当前对象的引用。 在当前类的方法中需要返回当前对象，可以直接return this。 在同一个类中的方法调用同一个类的另一个方法的时候，可以通过this.xxx(param)来调用，此时的this也可以省略。 一个构造器调用另外一个构造器，可以直接使用this，不可省略。 引用当前类的属性，如果在方法中引用，方法参数跟属性名称一样的时候不可省略。 1234567891011121314151617181920212223242526272829303132333435363738public class Tree &#123; private static final Integer DEFAULT_HEIGHT = 10; private Integer height; public Tree(Integer height) &#123; this.height = height; // 引用当前类的属性，不可省略 &#125; public Tree() &#123; this(DEFAULT_HEIGHT); // 通过this调用已经定义的构造器 &#125; public void shake() &#123; System.out.println(this.height + &quot;米高的树在摇动......&quot;); &#125; public void treeBreak() &#123; System.out.println(&quot;树从中间折断了......&quot;); this.height /= 2; // 引用当前类的属性，可省略 &#125; public void windBlow() &#123; this.shake(); // 通过this调用本类的方法 treeBreak(); // 省略this &#125; public static void main(String[] args) &#123; Tree tree = new Tree(); tree.windBlow(); System.out.println(&quot;树现在的高度是&quot; + tree.height + &quot;米&quot;); &#125;&#125;// output: 10米高的树在摇动......// 树从中间折断了......// 树现在的高度是5米 关于垃圾清理与回收 在一个应用程序中，每产生一个对象就意味着需要为其分配一块内存，但是系统内存是有限的，这就意味着我们需要释放废弃对象所占用的内存。Java有专门的垃圾回收器负责清理无用对象占用的内存。但是如果你的对象不是通过new的方式来创建的，Java垃圾回收器就不知道该如何释放该对象占用的内存，这种情况下Java允许类中定义一个finalize()方法。 Java垃圾回收机制 引用计数法：简单但是速度慢。当有新的引用指向对象的时候，计数器+1，当对象离开作用域或者被设置为null的时候，计数器-1，当发现某个引用计数器数值为0的时候，释放该对象。如果对象之间循环引用，会出现对象应该别回收，但是计数器不为0的情况。 从堆栈和静态存储去开始遍历所有的引用，然后可以根据引用找到所有活着的对象，然后在遍历对象所包含的引用的对象，直至完全停止。对于每个引用都必须追踪他所引用的对象。 停止-复制：先停止运行程序，然后把所有存活的对象从当前的堆复制到另外一个堆，同时需要修正指向这些对象的引用。没有被复制的就是垃圾。这种情况下新复制的堆中每个对象内存都是整齐排列的，保持紧凑。 但是这种回收机制效率会比较低：一方面是需要维护两块内存，然后在两块内存中互相倒腾。另一方面在程序稳定运行过程中可能只会产生极少量的垃圾，甚至是不产生垃圾，这时候再进行复制回收就会显得有点过于浪费了。 标记-清扫：对于一般用途而言，标记清扫很慢，但是配合停止-复制方法，在只产生少量垃圾甚至不产生垃圾的时候就会很快了。标记清扫跟第二种情况相似，是从堆栈和静态存储区遍历所有引用，没找到一个存活的对象，就会进行标记，这个过程中不会回收任何对象，直到全部标记工作完成之后才开始执行清理工作。","categories":[],"tags":[{"name":"Java中对象初始化以及Java虚拟机的垃圾回收机制","slug":"Java中对象初始化以及Java虚拟机的垃圾回收机制","permalink":"http://kfw5264.github.io/tags/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"}]},{"title":"设计模式学习（(Design Patterns)）","slug":"设计模式学习","date":"2020-08-12T13:46:13.000Z","updated":"2020-08-12T13:46:59.253Z","comments":true,"path":"2020/08/12/设计模式学习/","link":"","permalink":"http://kfw5264.github.io/2020/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、单例模式(Singleton)概念一个类只有一个实例，且该类能自行创建这种实例。 特点 只有一个实例 能自行创建实例 对外提供一个能访问该实例的全局访问点 应用 饿汉式 12345678910public class SingletonDmeo&#123; // 创建一个该类私有的对象 private SingletonDmeo instance = new SingletonDemo(); // 构造器私有化，禁止其他类创建对象 private SingletonDmeo()&#123;&#125; // 创建一个的静态方法返回对象 public static SingletonDemo getInstance()&#123; return this.instance; &#125; &#125; 简单明了且在多线程环境下可以不会收到任何影响 在类加载的时候就会产生一个该类的对象 懒汉式 12345678910111213public class SingletonDemo&#123; // 创建一个私有实例，但是不初始化 private SingletonDemo instance; // 构造器私有化，禁止其他类创建对象 private SingletonDmeo()&#123;&#125; // 创建一个的静态方法返回对象 public static SingletonDemo getInstance()&#123; if(instance == null)&#123; instance = new SingletonDemo(); &#125; return instance; &#125;&#125; 这种方法类加载的时候不会创建对象，只是在需要的时候判断实例是否为空，如果为空则创建一个。但是在多线程环境中使用该方法时这种方式可能会创建出多个实例。 12345678910public class SingletonDemo&#123; private volatile SingletonDemo instance; private SingletonDemo()&#123;&#125; public static synchronized SingletonDemo getInstance()&#123; if(instance == null)&#123; instance = new SingletonDemo(); &#125; return instance; &#125; &#125; 通过synchronized锁定方法中的代码，解决多线程中可能或出现的创建多个实例的问题。但是由于其他线程需要等待锁，所以效率比较慢。 1234567891011121314public class SingletoDemo&#123; private volatile SingletonDemo instance; private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; if(instance == null)&#123; synchronized &#123; if(instance == null)&#123; instance = new SingletonDemo(); &#125; &#125; &#125; return instance; &#125; &#125; Double Check提升效率，比较完美的方法。 内部类 123456789public class SingletonDemo&#123; private SingletonDemo()&#123;&#125; private static class SingletonDemoHolder&#123; private final static SingletonDemo INSTANCE = new SingletonDemo() &#125; public static SingletonDemo getInstance()&#123; return SingletonDemoHolder.INSTANCE; &#125;&#125; 枚举类（Effective Java推荐） 123public enum SingletonDemo&#123; INSTANCE;&#125; 二、原型模式(Prototype)概念 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个与原型相同或者相似的对象 通过原型模式创建对象非常高效，无需知道创建对象的细节。 结构 抽象原型类 具体原型类 访问类 应用12345678910111213141516171819202122public class MonkeySun implements Cloneable &#123; public MonkeySun()&#123; System.out.println(&quot;创建了一个孙悟空实例&quot;); &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; System.out.print(&quot;复制了一个孙悟空实例&quot;); return super.clone(); &#125;&#125;class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MonkeySun monkeySun = new MonkeySun(); MonkeySun monkeySunCopy = (MonkeySun) monkeySun.clone(); System.out.println(monkeySun == monkeySunCopy); //false &#125;&#125; 上述例子中MonkeySun为具体原型类，Java自带的Cloneable接口抽象原型类 三、工厂方法模式(Factory Method)概念 定义一个创建产品对象的接口，将产品对象的实际创捷工作推迟到具体的工厂类中。满足创建性模式的“创建与使用相分离”的特点。 优点以及缺点优点 客户端只需要知道具体工厂的名称就可以得到所需的产品，无需知道具体产品创建的过程， 系统增加新的产品时无需对原有工厂进行修改，只需要添加新的产品类以及与之对应的工厂类，满足开闭原则。 缺点 每增加一个产品就需要增加一个具体的产品类以及其对应的工厂类，这增加了系统的复杂度。 结构 抽象工厂(Abstract Factory)：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法createProduct()来创建产品 具体工厂(ConcreteFactory)：主要实现抽象工厂中的抽象方法，完成产品的创建 抽象产品(Product)：定义了产品的规范，描述了产品的主要特征和功能。 具体产品(ConcreteProduct)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它与具体工厂一一对应。 应用 汽车工厂接口 123public interface CarFactory&#123; public ICar createCar();&#125; 汽车接口 123public interface ICar&#123; public void energy();&#125; 特斯拉工厂 123456public class TeslaFactory implements ICarFactory &#123; @Override public ICar createCar() &#123; return new TeslaCar(); &#125;&#125; 奔驰工厂 123456public class BenzFactory implements ICarFactory &#123; @Override public ICar createCar() &#123; return new BenzCar(); &#125;&#125; 特斯拉汽车 123456public class TeslaCar implements ICar &#123; @Override public void energy() &#123; System.out.println(&quot;特斯拉使用电......&quot;); &#125;&#125; 奔驰汽车 1234567public class BenzCar implements ICar &#123; @Override public void energy() &#123; System.out.println(&quot;奔驰汽车用汽油.....&quot;); &#125;&#125; 四、抽象工厂模式概念 一种为访问类提供一个创建一组相关或者相互依赖的接口，且访问类不需要指定所需产品的具体类就可以得到同组不同等级的产品模式结构。 结构 抽象工厂(Abstract Factory)：提供创建产品的接口，包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂(Concrete Factory)：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品(Product)：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品 具体产品(Concrete Product)：实现了抽象产品角色所定义的接口，由具体工厂创建，它同具体工厂之间是多对一关系。 应用场景 需要创建的产品是一系列相互关联，相互依赖的产品组时。 系统中有多个产品组，但是每次只使用其中一族产品。 系统提供了产品的类库，且所有产品的接口相同。客户端不依赖产品实例的创建细节和内部结构。 五、建造者模式定义 将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。 将一个复杂的对象分为多个简单的对象，然后一步步构建而成。将变与不变分离，即产品的组成部分使不变的，但每一部分使可以灵活选择的。 优点与缺点 优点： 各个部分的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成细节，便于控制细节风险。 缺点： 产品的组成部分必须相同，限制了产品的使用部分。 如果产品内部变化复杂，该模式会增加很多的建造者类。 结构 产品角色(Product)：它是多个组成部件的复杂对象，由具体建造者来创建其各个部件。 抽象建造者(Builder)：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法getResult()。 具体建造者(Concrete Builder)：实现Builder接口，完成复杂产品的各个部件的具体创建方法。 指挥者(Director)：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 六、代理模式(Proxy)定义 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。 访问对象不能或者不适合直接引用对象，代理对象作为访问对象与目标对象之间的中介。 优点与缺点 优点 代理模式在客户端和目标对象中间起到一个中介作用和保护目标对象的作用。 代理对象可以扩展目标对象的功能。 代理模式能够将客户端与目标对象分离，在一定程度上降低了系统的耦合度。 缺点 在客户端和目标对象中间加了一个代理对象，或造成请求速度减慢。 增加了系统的复杂度。 结构 静态代理 抽象主题类(Subject)：通过接口或者抽象类声明真实主体和代理对象实现的业务方法。 123interface Subject&#123; void request();&#125; 真实主题类(Real Subject)：通过实现抽象主题中具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 123456class RealSubject implements Subject&#123; @Override public void request()&#123; System.out.println(&quot;访问真实主题方法...&quot;); &#125;&#125; 代理类(Proxy)：提供与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制和扩展真实主题的功能。 1234567891011121314151617181920class Proxy implements Subject&#123; private RealSubject realSubject; @Override public void request()&#123; if (realSubject == null) &#123; realSubject = new RealSubject(); &#125; preRequest(); realSubject.request(); afterRequest(); &#125; public void preRequest()&#123; System.out.println(&quot;访问真实主题之前的预处理......&quot;); &#125; public void afterRequest()&#123; System.out.println(&quot;访问真实主题之后的后续处理......&quot;); &#125; &#125; JDK动态代理 抽象主题类与真实主题类同上。 代理类不需要实现接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DynamicProxy &#123; // 定义一个目标对象 private Object target; public DynamicProxy(Object target)&#123; this.target = target; &#125; // 传统方法 public Object getProxyInstance()&#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; preRequest(); Object returnValue = method.invoke(target, args); afterRequest(); return returnValue; &#125; &#125; ); &#125; // lambda表达是 public Object getProxyInstanceLambda()&#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), (proxy, method, args) -&gt; &#123; preRequest(); Object returnValue = method.invoke(target, args); afterRequest(); return returnValue; &#125; ); &#125; private void preRequest()&#123; System.out.println(&quot;动态代理访问真实主题方法之前的预处理.......&quot;); &#125; private void afterRequest()&#123; System.out.println(&quot;动态代理访问真实主题之后的后续处理......&quot;); &#125;&#125; 七. 适配器模式(Adapter)定义 将一个类的接口转换成客户需要的接口，使得原本不兼容的而不能一起工作的那些类能够一起工作。 优点与缺点 优点： 客户端通过适配器可以透明的调用目标接口。 复用了现有的类，程序员不需要修改原有的代码而重用现有的适配器类。 将目标类与适配器类解耦，解决了目标类和适配者类接口不一致的问题。 缺点 对于适配器来说，更换适配器的实现过程比较复杂。结构与实现 目标接口(Target)：当前系统业务所期待的接口。1234public interface CommonInterface &#123; public void ListenMusicByCommonHeadset();&#125; 适配者类(Adaptee)：被访问和适配的现存组件库中的组件接口。123456public class TypeCPhone &#123; public void listenMusic()&#123; System.out.println(&quot;用type-c接口的耳机听音乐......&quot;); &#125;&#125; 适配器类(Adapter)：转化器，将适配者类转换成目标接口，让客户目标接口的格式访问适配者。 类适配器（不推荐，慎用继承）1234567public class ClassAdapter extends TypeCPhone implements CommonInterface &#123; @Override public void ListenMusicByCommonHeadset() &#123; System.out.println(&quot;借助Type-c转3.5mm接口的适配器听歌&quot;); this.listenMusic(); &#125;&#125; 对象适配器（推荐）1234567891011121314public class ObjectAdapter implements CommonInterface &#123; private TypeCPhone phone; public ObjectAdapter(TypeCPhone phone)&#123; this.phone = phone; &#125; @Override public void ListenMusicByCommonHeadset() &#123; System.out.println(&quot;借助Type-c转3.5mm接口的适配器听歌&quot;); phone.listenMusic(); &#125;&#125; 八、桥接模式(Bridge)定义 将抽象与实现分离，使其可以独立变化。用组合关系来代替继承来实现，从而降低了抽象和实现这两个可变维度的耦合度。 优点与缺点 优点： 由于抽象与实现相分离，所以扩展性比较强。 其实现细节对客户透明。缺点： 由于聚合关系建立在抽象层，要求开发者对抽象层进行设计和编程，增加了系统的设计和理解难度。 结构与实现 抽象化角色(Abstraction)：定义抽象类，并包含一个对实现化对象的引用。123456789101112public abstract class Abstraction &#123; // 子类需要继承，所以是protected protected Implementor implementor; public Abstraction(Implementor implementor)&#123; this.implementor = implementor; &#125; abstract void doThings();&#125; 扩展抽象化角色(Refined Abstraction)：抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。1234567891011public class RefinedAbstraction extends Abstraction &#123; public RefinedAbstraction(Implementor implementor) &#123; super(implementor); &#125; @Override void doThings() &#123; System.out.println(&quot;具体实现化角色&quot;); implementor.doSomething(); &#125;&#125; 实现化角色(Implementor)：定义实现化角色的接口，供扩展实现化角色调用。1234public interface Implementor &#123; public void doSomething(); &#125; 具体实现化角色(Concrete Implementor)：给出实现化角色接口的具体实现。123456public class ConcreteImplementor implements Implementor &#123; @Override public void doSomething() &#123; System.out.println(&quot;扩展抽象化角色&quot;); &#125; &#125; 九、装饰模式(Decorator)定义 在不改变现有对象结构的情况下，动态的给对象增加一些职责的模式。它属于对象结构型模式。 优点和缺点优点： 采用装饰模式扩展对象的功能比采用继承方式更加灵活。 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。 缺点： 装饰模式增加了很多子类，如果过度使用会使程序变得很复杂。 结构与应用 抽象构件(Component)：定义一个抽象接口以规范准备接收附加责任的对象。123public interface Component &#123; public void doSomething();&#125; 具体构件(Concrete Component)：实现抽象构建，通过装饰角色为其添加一些职责。123456public class ConcreteComponent implements Component &#123; @Override public void doSomething() &#123; System.out.println(&quot;具体构件的方法&quot;); &#125;&#125; 抽象装饰角色(Decorator)：继承抽象构建，并包含具体构建的实例。可以通过其子类扩展构件的功能。123456789101112public abstract class Decorator implements Component &#123; private Component component; public Decorator(Component component)&#123; this.component = component; &#125; @Override public void doSomething() &#123; component.doSomething(); &#125;&#125; 具体装饰角色(Concrete Decorator)：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。123456789101112131415public class ConcreteDecorator extends Decorator &#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; @Override public void doSomething() &#123; super.doSomething(); addFunction(); &#125; private void addFunction() &#123; System.out.println(&quot;附加功能!&quot;); &#125;&#125; 十、外观模式(Facade)定义 通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易访问的模式。该模式对外有一个统一的接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 优点与缺点优点： 降低了子系统与客户端之间的耦合度，是的子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程。 缺点： 不能很好的限制客户使用子系统类。 增加新的子系统可能需要修改外观类或客户端的源代码，违反了开闭原则。 结构与应用 外观角色(Facade)：为多个子系统提供一个统一的接口。1234567891011121314151617181920212223public class Facade &#123; private SubSystemA systemA; private SubSystemB systemB; private SubSystemC systemC; public Facade()&#123; systemA = new SubSystemA(); systemB = new SubSystemB(); systemC = new SubSystemC(); &#125; public void methodA()&#123; systemA.doSomethingA(); &#125; public void methodB()&#123; systemB.doSomethingB(); &#125; public void methodC()&#123; systemC.doSomethingC(); &#125;&#125; 子系统角色(Sub System)：实现系统的部分功能，客户可以通过外观角色访问它。1234567891011121314151617181920class SubSystemA &#123; public void doSomethingA()&#123; System.out.println(&quot;子系统方法A&quot;); &#125;&#125;class SubSystemB &#123; public void doSomethingB()&#123; System.out.println(&quot;子系统方法B&quot;); &#125;&#125;class SubSystemC &#123; public void doSomethingC()&#123; System.out.println(&quot;子系统方法C&quot;); &#125;&#125; 客户角色(Client)：通过一个外观角色访问各个子系统的功能。12345678910public class App &#123; @Test public void testMethod()&#123; Facade facade = new Facade(); facade.methodA(); facade.methodB(); facade.methodC(); &#125;&#125; 十一、享元模式(Flyweight)定义 运用共享技术来有效的支持大量细粒度对象的复用。通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。 优点与缺点 优点： 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 缺点： 为了使对象可以共享，需要将一些不能共享的状态外部化，增加了程序的复杂度。 读取享元模式的外部状态会使得运行时间稍微变长。 结构与实现 状态 内部状态：不会随着环境改变而改变的可共享部分。 外部状态：指随环境改变而不可共享的部分。 结构 抽象享元角色(Flyweight)：所有具体享元类的基类，为具体享元规范需要实现的公共接口，非享元外部状态以参数形式通过方法传入。123public interface Flyweight &#123; void doSomething(UnsharableFlyweight unsharableFlyweight);&#125; 具体享元角色(Concrete Flyweight)：实现抽象享元角色中所规定的接口。1234567891011121314public class ConcreteFlyweight implements Flyweight &#123; private String key; public ConcreteFlyweight(String key) &#123; this.key = key; &#125; @Override public void doSomething(UnsharableFlyweight unsharableFlyweight) &#123; System.out.println(&quot;具体享元&quot;); System.out.println(&quot;非享元信息是：&quot;+unsharableFlyweight.getInfo()); &#125;&#125; 非享元角色(Unsharable Flyweight)：使不可共享的外部状态，以参数的形式注入具体享元角色中。1234567891011121314public class UnsharableFlyweight &#123; private String info; public UnsharableFlyweight(String info)&#123; this.info = info; &#125; public String getInfo()&#123; return info; &#125; public void setInfo()&#123; this.info = info; &#125;&#125; 享元工厂角色(Flyweight Factory)：负责创建和管理享元角色。12345678910111213141516public class FlyweightFactory &#123; private Map&lt;String, Flyweight&gt; flyweightMap = new HashMap&lt;&gt;(); public Flyweight getFlyweight(String key) &#123; Flyweight flyweight = flyweightMap.get(key); if (flyweight != null) &#123; System.out.println(&quot;具体享元对象&quot;+key+&quot;已经存在&quot;); &#125;else&#123; flyweight = new ConcreteFlyweight(key); flyweightMap.put(key, flyweight); &#125; return flyweight; &#125;&#125; 十二、组合模式(Composite)定义 将对象组合成树状层次的结构，用来表示部分及整体的关系，使用户对单个对象以及组合对象具有一致的访问性。 优点与缺点优点： 组合模式可以使客户端可以一致的访问单个对象和组合对象，无需关系自己处理的使单个对象还是组合对象。简化了客户端代码。 更容易在组合体内加入新的对象，客户端不会因为加入新的对象而改变代码，满足开闭原则。 缺点： 设计较为复杂，客户端需要更多的时间清理类之间的关系。 不容易限制容器内的构件。 不容易用继承的方法来增加构件的新功能。 结构与实现 抽象构件(Component)：为树叶构件和树枝构件声明公共接口，并实现他们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作有树枝构件完成。123456public interface Component &#123; public void add(Component component); public void remove(Component component); public Component getChild(int i); public void operate();&#125; 树叶构件角色(Leaf)：组合中的叶节点对象，没有子节点，用于实现抽象构件角色中生命的公共接口。1234567891011121314151617181920212223public class Leaf implements Component &#123; private String name; public Leaf(String name) &#123; this.name = name; &#125; @Override public void add(Component component) &#123;&#125; @Override public void remove(Component component) &#123;&#125; @Override public Component getChild(int i) &#123; return null; &#125; @Override public void operate() &#123; System.out.println(&quot;树叶&quot;+name+&quot;被访问&quot;); &#125;&#125; 树枝构件对象(Composite)：组合中的分支节点对象，有子节点。实现了抽象构件角色中声明的接口，主要作用是存储和管理子部件，通常包含add(), remove(), getChild()等方法。1234567891011121314151617181920212223242526public class Composite implements Component &#123; private List&lt;Component&gt; children = new ArrayList&lt;&gt;(); @Override public void add(Component component) &#123; children.add(component); &#125; @Override public void remove(Component component) &#123; children.remove(component); &#125; @Override public Component getChild(int i) &#123; return children.get(i); &#125; @Override public void operate() &#123; for (Component component : children) &#123; component.operate(); &#125; &#125;&#125; 十三、模板方法模式(Template Method)定义 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类不改变该算法的结构情况下重定义该算法的某些特定步骤。 优点与缺点优点： 封装了不可变部分，扩展了可变部分。 在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点： 对每个不同的实现都要定义一个子类，这回导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行结果会影响父类的结果。这导致一种反向的控制结构，提高了代码阅读的难度。 结构与实现 抽象类(Abstract Class)：负责给出一个算法的轮廓和骨架，它是由一个模板方法和若干基本方法组成。这些方法的定义如下： 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 基本方法：整个算法中的一个步骤，包含以下几种类型。 抽象方法：在抽象类中声明，具体子类实现。 具体方法：抽象类中实现，具体子类可以继承或者重写。 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和子类重写的方法两种。12345678910111213141516public abstract class AbstractClass &#123; public void templateMethod()&#123; specificMethod(); abstractMethodA(); abstractMethodB(); &#125; // 具体方法 public void specificMethod() &#123; System.out.println(&quot;具体方法被调用&quot;); &#125;; // 抽象方法1 public abstract void abstractMethodA(); // 抽象方法2 public abstract void abstractMethodB();&#125; 具体子类(Concrete Class)：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成部分。 1234567891011public class ConcreteClass extends AbstractClass &#123; @Override public void abstractMethodA() &#123; System.out.println(&quot;抽象类的抽象方法A&quot;); &#125; @Override public void abstractMethodB() &#123; System.out.println(&quot;抽象类的抽象方法B&quot;); &#125;&#125; 十四、策略模式(Strategy)定义 定义了一些列算法，并将每个算法封装起来，使他们可以互相替换，且算法的变化不影响使用算法的客户。策略模式属于对象行为模式，通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 优点与缺点优点： 多重条件语句不宜维护，而使用策略模式可以避免使用多重条件语句。 策略模式提供了一系列可供重用的算法族，恰当使用继承可以把算法的公共代码移交到父类中，从而避免了重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同情况使用不同的策略。 策略模式提供了对开闭原则的完美实现，可以在不修改源代码的情况下灵活增加不同的算法。 策略模式把算法使用放到环境类中，而算法的具体实现移交到策略类中，实现了二者的分离。 缺点： 客户端必须理解所有算法的区别，以便恰当时机选择恰当的算法。 策略模式造成很多的策略类。 结构与实现 抽象策略类(Strategy)：定义一个公共接口，各种不同算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法。123public interface TravelStrategy &#123; public void travelMode();&#125; 具体策略类(Concrete Strategy)：实现抽象策略定义的接口，提供具体的算法实现。1234567891011121314151617181920public class TravelByCar implements TravelStrategy &#123; @Override public void travelMode() &#123; System.out.println(&quot;开车去旅行...&quot;); &#125;&#125;public class TravelByPlain implements TravelStrategy &#123; @Override public void travelMode() &#123; System.out.println(&quot;坐着飞机去旅行...&quot;); &#125;&#125;public class TravelByTrain implements TravelStrategy &#123; @Override public void travelMode() &#123; System.out.println(&quot;坐火车去旅行。。。&quot;); &#125;&#125; 环境类(Context)：持有一个策略类的引用，最终给客户端调用。123456789101112public class Traveler &#123; private TravelStrategy travelStrategy; public Traveler(TravelStrategy travelStrategy) &#123; this.travelStrategy = travelStrategy; &#125; public void travel()&#123; travelStrategy.travelMode(); &#125;&#125; 十五、命令模式(Command)定义 将一个请求封装成一个对象，使发出请求的责任和执行请求的责任分隔开。这样两者之间通过命令对象进行沟通，方便将命令进行储存、传递、调用、增加和管理。 优点与缺点优点： 降低系统的耦合度。命令模式能够将调用操作的对象和实现该操作的对象解耦。 增加或删除命令非常方便。采用命令模式增加和删除命令不会影星其他类。满足开闭原则，对扩展比较灵活。3，可以实现宏命令。命令模式和组合模式相结合，将多个命令组装成一个组合命令。4。 方便实现Undo 和 Redo 模式。命令模式可以备忘录模式相结合，实现命令的撤销和恢复。 缺点： 产生大量的命令类，增加系统的复杂度。 结构与实现 抽象命令类角色(Command)：声明执行命令的接口，拥有执行命令的抽象方法execute()。123public interface Command &#123; void execute();&#125; 具体命令类角色(Concrete Command)：是抽象命令角色的具体实现类，拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。12345678910111213public class ConcreteCommand implements Command &#123; private Receiver receiver; public ConcreteCommand() &#123; this.receiver = new Receiver(); &#125; @Override public void execute() &#123; receiver.action(); &#125;&#125; 实现者/接收者角色(Receiver)：执行命令功能的相关操作，是具体命令对象业务的具体实现。12345public class Receiver &#123; public void action() &#123; System.out.println(&quot;执行Receiver的action方法&quot;); &#125;&#125; 调用者/请求者角色(Invoker)：是请求的发送者，通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，不直接访问接收者。1234567891011public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void call() &#123; command.execute(); &#125;&#125; 十六、责任链模式(Chain Of Responsibility)定义 为了避免请求发送与多个请求处理者耦合在一起，将所有对象通过前一对象记住其下一个对象的引用而连成一条链，当有请求发生时，可以连着这条链，直到对象处理完为止， 优点与缺点优点： 降低了对象之间的耦合度。一个对象无需知道是哪一个对象处理其请求以及链的结构，发送者与接收者也无需拥有对方明确的信息。 增强了系统的可扩展性。可以根据需求增加新的请求处理类，满足开闭原则。 增强了给对象指派职责的灵活性。工作流程发生改变是可以动态改变链内的成员顺序或者调动他们的次序，也可以动态的增加或者删除责任。 简化了对象之间的连接。每个对象只需保持一个后继者的引用，而不用关心其他对象。 责任分担，每个对象秩序处理自己该做的工作，不该处理的留给下一个对象。 缺点： 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不一定能保证其被处理，该请求可能传递到末端链都得不到处理。 对比较长的责任链，请求的处理可能涉及到多个处理对象，系统性能将收到一定影响。 责任链的合理性需要客户端来保证，增加了客户端的复杂性，可能会因为职责链设置错误而导致系统出错，也可能会循环调用。 结构与实现 抽象处理者角色(Handle)：定义一个处理请求的接口，包括抽象处理方法和一个后继链接。12345678910111213public abstract class Handler &#123; private Handler next; public Handler getNext() &#123; return next; &#125; public void setNext(Handler next) &#123; this.next = next; &#125; public abstract void handleRequest(String request);&#125; 具体处理者角色(Concrete Handle)：实现抽象处理者的处理方法，判断是否本次处理，如果可以请求则处理，否则将请求转给后续处理者。12345678910111213141516171819202122232425public class ConcreteHandlerA extends Handler &#123; @Override public void handleRequest(String request) &#123; if (request.equals(&quot;first&quot;)) &#123; System.out.println(&quot;具体处理者A负责处理&quot;); &#125; else if (getNext() != null) &#123; getNext().handleRequest(request); &#125; else &#123; System.out.println(&quot;没有人处理&quot;); &#125; &#125;&#125;public class ConcreteHandlerB extends Handler &#123; @Override public void handleRequest(String request) &#123; if (request.equals(&quot;second&quot;)) &#123; System.out.println(&quot;具体处理者B负责处理&quot;); &#125; else if (getNext() != null) &#123; getNext().handleRequest(request); &#125; else &#123; System.out.println(&quot;没有人处理&quot;); &#125; &#125;&#125; 客户类角色(Client)：创建处理链，并向链头的具体处理者提交请求，他不关心处理细节和请求传递。12345678910public class Client &#123; public void invokeChain() &#123; Handler handlerA = new ConcreteHandlerA(); Handler handlerB = new ConcreteHandlerB(); handlerA.setNext(handlerB); handlerA.handleRequest(&quot;second&quot;); &#125;&#125; 十七、状态模式定义 对有状态的对象，把复杂的判断逻辑提取到不同的状态对象中，允许状态对象在内部发生改变时改变其行为。 优点与缺点优点： 状态模式将与特定状态相关的行为局部化到一个状态中。并且将不同状态的行为分割开来，满足单一职责原则。 减少对象间的相互依赖。将不同状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间相互转换。 有利于程序的扩展。通过定义新的子类很容易增加新的状态和转换。 缺点： 增加系统类以及对象个数。 结构与实现较为复杂，使用不当会引起结构和代码的混乱。结构与实现 环境角色(Context)：也成为上下文，定义了客户感兴趣的接口，维护一个当前状态，并将于状态相关的操作委托给当前的状态对象来处理。1234567891011121314151617181920public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; System.out.println(&quot;当前状态为&quot;+state.name); &#125; public void request() &#123; state.handle(this); //对请求做处理并指向下一个状态 &#125;&#125; 抽象状态角色(State)：定义一个接口，用来封装环境对象中特定状态对应的行为。12345public abstract class State &#123; public String name; public abstract void handle(Context context);&#125; 具体状态角色(Concrete State)：实现抽象状态所对应的行为。123456789101112131415161718192021222324252627public class ConcreteStateA extends State &#123; public ConcreteStateA() &#123; this.name = &quot;A&quot;; &#125; @Override public void handle(Context context) &#123; System.out.println(this.name); context.setState(new ConcreteStateB()); &#125;&#125;public class ConcreteStateB extends State &#123; public ConcreteStateB() &#123; this.name = &quot;B&quot;; &#125; @Override public void handle(Context context) &#123; System.out.println(&quot;&quot;); context.setState(new ConcreteStateA()); &#125;&#125; 十八、 观察者模式(Observer)定义 多个对象间存在一对多依赖关系，当一个对象的状态发生变化时， 所有依赖它的对象都得到通知并自动更新。观察者模式又称为发布订阅模式、模型、视图模式。 优点与缺点优点： 降低了目标与观察者之间的耦合关系。 目标与观察者之间建立了一套触发机制。 缺点： 目标与观察者之间的依赖关系并没有完全消除，而且有可能发生循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 结构与实现 抽象主题角色(Subject)：也叫抽象目标类，提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法。以及所有通知观察者的抽象方法。1234567891011121314public abstract class Subject &#123; protected List&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); // 添加观察者 public void add(Observer observer) &#123; observers.add(observer); &#125; // 移除观察者 public void remove(Observer observer) &#123; observers.remove(observer); &#125; public abstract void notifyObserver();&#125; 具体主题角色(Concrete Subject)：也叫具体目标类，实现抽象目标中的通知方法，当具体主题发生变化时，通知所有注册过的观察者对象。123456789public class ConcreteSubject extends Subject &#123; @Override public void notifyObserver() &#123; System.out.println(&quot;目标发生改变，调用观察者&quot;); for (Observer observer : observers) &#123; observer.response(); &#125; &#125;&#125; 抽象观察者角色(Observer)：它是一个抽象类的接口，包含一个更新自己的方法，且接到具体主题角色的通知时被调用。123public interface Observer &#123; void response();&#125; 具体观察者角色(Concrete Observer)：实现抽象观察者定义的抽象方法，以便在目标得到更改时更新自身的状态。12345678910111213public class ConcreteObserverA implements Observer &#123; @Override public void response() &#123; System.out.println(&quot;观察者A作出响应&quot;); &#125;&#125;public class ConcreteObserverB implements Observer &#123; @Override public void response() &#123; System.out.println(&quot;观察者B作出响应&quot;); &#125;&#125; 十九、中介者模式(Mediator)定义 定义一个中介来封装一些列对象之间的交互，使原有对象之间的耦合松散，且可以独立改变他们之间的交互。 优点与缺点优点： 降低了对象之间的耦合，使得对象易于独立的复用。 将对象中的一对多关联变为一对多关联，提高系统的灵活性，使得系统更加容易维护。 缺点： 当同事类过多的情况下，中介者的职责会变得负责而庞大，以致于系统难以维护。 结构与实现 抽象中介者(Mediator)：中介者的接口，提供了同事对象的注册与转发同事对象的抽象方法。1234public interface Mediator &#123; void register(Colleague colleague); void relay(Colleague colleague);&#125; 具体中介者(Concrete Mediator)：实现抽象中介者的接口。定义一个List来管理同事对象，协调各个同事之间的相互交互，因此依赖于同事角色。12345678910111213141516171819public class ConcreteMedia implements Mediator &#123; private Set&lt;Colleague&gt; colleagues = new HashSet&lt;&gt;(); @Override public void register(Colleague colleague) &#123; colleagues.add(colleague); colleague.setMediator(this); &#125; @Override public void relay(Colleague col) &#123; for (Colleague colleague : colleagues) &#123; if(!col.equals(colleague)) &#123; colleague.receive(); &#125; &#125; &#125;&#125; 抽象同事类(Colleague)：定义同事类接口，保存中介者对象，提供同事对象相互交互的抽象方法，实现所有相互影响的同事类的所有功能。1234567891011public abstract class Colleague &#123; protected Mediator mediator; public void setMediator(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void receive(); public abstract void send();&#125; 具体同事类(Concrete Colleague)：抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。12345678910111213141516171819202122232425public class ConcreteColleagueA extends Colleague &#123; @Override public void receive() &#123; System.out.println(&quot;同事类A接收到请求&quot;); &#125; @Override public void send() &#123; System.out.println(&quot;同事类A发送请求&quot;); mediator.relay(this); &#125;&#125; public class ConcreteColleagueB extends Colleague &#123; @Override public void receive() &#123; System.out.println(&quot;同事类B接收请求&quot;); &#125; @Override public void send() &#123; System.out.println(&quot;同事类B发送请求&quot;); mediator.relay(this); &#125;&#125; 二十、迭代器模式(Iterator)定义 提供一个对象来顺序访问聚合对象中的一系列数据，而不暴漏聚合对象的内部表示。 优点与缺点优点： 访问一个聚合对象无需暴漏内部表示。 遍历任务交给迭代器完成，这简化了聚合类。 它支持以不同方式遍历一个集合，甚至可以自定义迭代器的子类以支持新的遍历。 增加新的聚合类和迭代器类都很方便，无需修改原有代码。 封装性良好，为遍历不同的集合提供一个统一的接口。 缺点： 增加类的个数，这在一定程度上增加了系统的复杂性。 结构与实现 抽象聚合角色(Aggregate)：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。12345public interface Aggregate &#123; void add(Object obj); void remove(Object obj); public Iterator getIterator();&#125; 具体聚合角色(Concrete Aggregate)：实现抽象聚合类，返回一个具体迭代器的实例。12345678910111213141516171819public class ConcreteAggregate implements Aggregate &#123; List&lt;Object&gt; list = new ArrayList&lt;&gt;(); @Override public void add(Object obj) &#123; list.add(obj); &#125; @Override public void remove(Object obj) &#123; list.remove(obj); &#125; @Override public Iterator getIterator() &#123; return new ConcreteIterator(list); &#125;&#125; 抽象迭代器角色(Iterator)：定义访问和遍历聚合元素的接口，通常包含hasNext()、first()、next()等方法。12345public interface Iterator &#123; Object first(); Object next(); boolean hasNext();&#125; 具体迭代器角色(Concrete Iterator)：实际抽象迭代器中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。1234567891011121314151617181920212223242526272829303132333435public class ConcreteIterator implements Iterator &#123; private List&lt;Object&gt; list = null; private int index = -1; public ConcreteIterator(List&lt;Object&gt; list) &#123; this.list = list; &#125; @Override public Object first() &#123; index=0; Object obj=list.get(index);; return obj; &#125; @Override public Object next() &#123; Object obj=null; if(this.hasNext()) &#123; obj=list.get(++index); &#125; return obj; &#125; @Override public boolean hasNext() &#123; if(index&lt;list.size()-1) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 二十一、访问者模式(Visitor)定义 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中每个元素提供更多的访问方式。 优点与缺点优点： 扩展性好。能够在不修改对象结构的元素的情况下，为对象结构中的元素添加新的功能。 复用性好。可以通过访问者来定义整个对象结构通用功能，从而提高系统的复用程度。 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由的演化而不影响系统的数据结构。 符合单一职责原则。访问者模式把相关行为封装在一起，构成一个访问者，使得每个访问者功能都比较单一。 缺点： 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体的访问类中增加相应的具体操作，这违背了“开闭原则”。 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。 违背了依赖倒置原则。访问者模式以来了具体类，而没有依赖抽象类。 结构与实现 抽象访问者角色(Visitor)：定义一个访问具体元素的接口，为每一个具体元素类对应一个访问操作visit()，该操作中的参数类型表示了被访问的具体元素。1234public interface Visitor &#123; void visit(ConcreteElementA elementA); void visit(ConcreteElementB elementB);&#125; 具体访问者角色(Concrete Visitor)：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。1234567891011121314151617181920212223public class ConcreteVisitorA implements Visitor &#123; @Override public void visit(ConcreteElementA elementA) &#123; System.out.println(&quot;具体访问者A--&gt;&quot;+elementA.operationA()); &#125; @Override public void visit(ConcreteElementB elementB) &#123; System.out.println(&quot;具体访问者A--&gt;&quot;+elementB.operationA()); &#125;&#125;public class ConcreteVisitorB implements Visitor &#123; @Override public void visit(ConcreteElementA elementA) &#123; System.out.println(&quot;具体访问者B--&gt;&quot;+elementA.operationA()); &#125; @Override public void visit(ConcreteElementB elementB) &#123; System.out.println(&quot;具体访问者B--&gt;&quot;+elementB.operationA()); &#125;&#125; 抽象元素角色(Element)：声明一个包含接收accept()的接口，被接收的访问者对象作为accept()方法的参数。123public interface Element &#123; void accept(Visitor visitor);&#125; 具体元素角色(Concrete Element)：实现抽象元素角色提供的accept()操作，其方法通常是visitor.visit(this)，具体操作元素中可能还包含本身业务逻辑的相关操作。1234567891011121314151617181920public class ConcreteElementA implements Element &#123; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public String operationA() &#123; return &quot;具体元素A的操作&quot;; &#125;&#125;public class ConcreteElementB implements Element &#123; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public String operationA() &#123; return &quot;具体元素B的操作&quot;; &#125;&#125; 对象结构角色(Object Structure)：是一个包含元素角色的容器，提供让访问者对象遍历容器中所有元素的方法，通常由List、Map、Set等聚合类实现。123456789101112131415161718public class ObjectStructure &#123; private List&lt;Element&gt; list = new ArrayList&lt;Element&gt;(); public void accept(Visitor visitor) &#123; Iterator&lt;Element&gt; i = list.iterator(); while (i.hasNext()) &#123; ((Element) i.next()).accept(visitor); &#125; &#125; public void add(Element element) &#123; list.add(element); &#125; public void remove(Element element) &#123; list.remove(element); &#125;&#125; 二十二、备忘录模式(Memento)定义 在不破换封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个对象，以便在之后使用的时候恢复到原先使用的状态。 优点与缺点优点： 提供了一种可恢复状态的机制。当用户需要的时候能够方便的将状态恢复到某个历史值。2。 实现了内部状态的封装，除了创建它的发起人之外，其他对象都不能访问这些状态信息。 简化了发起人类。发起人不需要管理和保存其内部状态，所有状态均保存在备忘录中，并由管理者进行管理，这符合单一职责原理。 缺点： 资源消耗过大。如果需要保存的内部状态比较多或者比较繁琐，将会占用大量的资源。 结构与实现 发起人角色(Originator)：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，可以访问备忘录里的所有信息。12345678910111213141516171819public class Originator &#123; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public Memento createMemento() &#123; return new Memento(state); &#125; public void restoreMemento(Memento memento) &#123; this.setState(memento.getState()); &#125;&#125; 2。 备忘录角色(Memento)：负责存储发起人的内部信息，在需要的时候提供给状态的发起人。12345678910111213141516public class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125;&#125; 管理者角色(Caretaker)：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容和功能进行访问与修改。1234567891011public class Cretaker &#123; private Memento memento; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125;&#125; 二十三、解释器模式(Interpreter)定义 给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解析语言中的句子。也就是说，用编译器语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。 优点与缺点优点： 扩展性好。由于解释器是使用类来表示语言的文法规则，因此可以同科继承等机制来改变或扩展文法。 容易实现。在语法数中的每个表达式节点都是相似的，所以实现其文法比较容易。 缺点： 执行效率低。解释器中通常使用大量的循环或递归调用，当要解释的句子比较复杂时，其运行速度很慢，且代码的调试也比较麻烦。 会引起类膨胀。解释器模式中每条规则至少定义一个类，当包含文法规则很多时，类的个数将急剧增加，导致系统难以管理和维护。 可应用场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。 结构与实现 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。","categories":[],"tags":[{"name":"设计模式学习笔记","slug":"设计模式学习笔记","permalink":"http://kfw5264.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}],"categories":[],"tags":[{"name":"Java中对象初始化以及Java虚拟机的垃圾回收机制","slug":"Java中对象初始化以及Java虚拟机的垃圾回收机制","permalink":"http://kfw5264.github.io/tags/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"name":"设计模式学习笔记","slug":"设计模式学习笔记","permalink":"http://kfw5264.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}