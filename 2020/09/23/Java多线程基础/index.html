<!DOCTYPE html><html class="html-loading"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Java多线程基础 | 暮爱深秋</title><meta name="author" content="康发伟"><meta name="keywords" content="java 程序员 计算机 学习"><meta name="description" content="新手程序员的成长史"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/Annie.css"><script src="/plugin/jquery/jquery.min.js"></script><script>const CONFIG_BGIMAGE = {
      mode: 'normal',
      normalSrc: '/img/header-bg.jpg',
      randomYouMax: 110,
      randomYouSrc: 'https://sariay.github.io/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: true
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: false,
	  appId: 'AU8...',
	  appKey: '4cU...',
	  serverURLs: 'http' || ' '
    }</script><meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="暮爱深秋" type="application/atom+xml"></head><body><div id="preloader"><div class="pre-container"><div class="spinner"><div class="double-bounce1"></div><div class="double-bounce2"></div></div></div></div><header class="fixbackground bg-pan-br"><div class="mask"><div class="h-body"><div class="motto text-shadow-pop-left"><p class="content" id="motto-content">获取中...</p><p>-</p><p></p><p class="author" id="motto-author">Just a minute...</p></div></div><div class="h-footer"><a href="javascript:;" id="read-more" class="scroll-down"><span class="icon-anchor1 animation-scroll-down"></span></a></div></div></header><div id="navigation-hide"><div id="progress-bar"></div><div id="progress-percentage"><span>0.0%</span></div><div class="toc-switch"><span class="switch-button">目录</span></div><p>「Java多线程基础」</p><a class="nav-trigger"><span></span></a></div><nav class="nav-container" id="cd-nav"><div class="nav-header"><span class="logo"><img src="/img/logo.png"> </span><a href="javascript:;" class="nav-close"></a></div><div class="nav-body"><ul id="global-nav"><li class="menu-home"><a href="/" class="menu-item-home" target="_blank">主页</a></li><li class="menu-archive"><a href="/archives" class="menu-item-archive" target="_blank">归档</a></li><li class="menu-categories"><a href="/categories" class="menu-item-categories" target="_blank">分类</a></li><li class="menu-tags"><a href="/tags" class="menu-item-tags" target="_blank">标签</a></li><li class="menu-about"><a href="/about" class="menu-item-about" target="_blank">关于</a></li><li class="menu-gallery"><a href="/gallery" class="menu-item-gallery" target="_blank">相册</a></li></ul></div><div class="nav-footer"><ul id="global-social"><li><a href="http://github.com/" target="_blank"><span class="icon-one"><span class="path1"></span><span class="path2"></span></span></a></li><li><a href="http://github.com/" target="_blank"><span class="icon-zhihu"></span></a></li><li><a href="http://github.com/" target="_blank"><span class="icon-github"></span></a></li><li><a href="http://github.com/" target="_blank"><span class="icon-sina-weibo"></span></a></li><li><a href="http://github.com/" target="_blank"><span class="icon-pinterest2"></span></a></li><li><a href="http://github.com/" target="_blank"><span class="icon-instagram"></span></a></li><li><a href="http://github.com/" target="_blank"><span class="icon-twitter"></span></a></li><li><a href="/atom.xml" target="_blank"><span class="icon-rss"></span></a></li></ul></div></nav><main><div class="layout-toc"><div id="layout-toc"><div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div></div></div><script src="/plugin/toc/katelog.min.js"></script><div class="layout-post"><div id="layout-post"><div class="article-title"><a href="/2020/09/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url">Java多线程基础</a></div><div class="article-meta"><span><i class="icon-calendar1"></i> 更新于 <a href="/2020/09/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url"><time datetime="2020-09-23T12:50:45.000Z" itemprop="dateUpdated">2020-09-23 </time></a></span><span><i class="icon-price-tags"></i> <a href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">Java多线程基础</a></span></div><div class="article-content" id="article-content"><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><h4 id="一、线程、进程、纤程"><a href="#一、线程、进程、纤程" class="headerlink" title="一、线程、进程、纤程"></a>一、线程、进程、纤程</h4><ul><li>进程：OS分配资源的基本单位。OS会为每一个进程独立分配一部分资源，每个进程的资源都有独立的内存空间。每个进程对应一个端口号。</li><li>线程：CPU调度的基本单位。共享进程的内存空间，线程没有独立的内存空间。</li><li>纤程：相当于用户空间的线程。纤程存在与用户态，不与内核打交道，所以速度会更快，且占用资源比较少。</li></ul><h4 id="二、创建线程的方式"><a href="#二、创建线程的方式" class="headerlink" title="二、创建线程的方式"></a>二、创建线程的方式</h4><ol><li><p>Thread：继承Thread类并重写run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread01</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过Thread.start方法启动线程</span></span><br><span class="line">        <span class="keyword">new</span> MyThread01().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Runnable：实现Runnable接口，重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过Thread.start方法启动线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread02()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>线程池：</p><ul><li><p>使用线程池的几个优点：</p><ol><li>降低资源消耗：通过重用已经创建好的线程来减少创建线程时的消耗。</li><li>提高响应速度：任务到达时不需要等待线程创建就可以立即执行。</li><li>提高线程的客观理性：线程可以统一管理、分配、调优和监控。</li></ol></li><li><p><code>ThreadPoolExecutor</code>创建线程池：</p><p><code>ThreadPoolExecutor</code>提供了四个构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>corePoolSize</code>：核心池的大小。默认情况下，在创建线程池后，线程池的线程数为0，当有新任务时，就会创建一个线程去执行任务，当线程池中的线程数量达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中。</li><li><code>maximumPoolSize</code>：线程池的最大线程数，表示线程池中最多能创建多少个线程。</li><li><code>keepAliveTime</code>：表示线程没有任务执行时最多存活时间。默认情况下，只有当线程数大于<code>maximumPoolSize</code>时，<code>keepAliveTime</code>才会起作用。</li><li><code>unit</code>：参数<code>keepAliveTime</code>的时间单位。</li><li><code>workQueue</code>：一个阻塞队列，用于存储等待执行的任务。</li><li><code>threadFactory</code>：线程工厂，用来创建线程。</li><li><code>handler</code>：表示当拒绝任务时的策略，有四种取值：<ul><li><code>ThreadPoolExecutor.AbortPolicy</code>:丢弃任务并抛出<code>RejectedExecutionException</code>异常。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛出异常。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class MyThread03&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2, &#x2F;&#x2F; 核心线程数</span><br><span class="line">                4, &#x2F;&#x2F; 最大线程数</span><br><span class="line">                5000, TimeUnit.MILLISECONDS,  &#x2F;&#x2F; 线程没有执行任务时最多存活时间</span><br><span class="line">                new LinkedBlockingDeque&lt;&gt;()</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            executor.execute(new ThreadTask());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ThreadTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>Java通过<code>Executors</code>提供四种线程池（不推荐，缓存队列<code>LinkedBlockingQueue</code>没有设置固定容量大小， 并发量多的时候容易发生OOM），分别是：</p><ol><li><code>newCachedThreadPools</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可以灵活回收空闲线程，若无可回收则创建线程。</li><li><code>newFixedThreadPools</code>创建一个定长线程池，可控制最大线程数，超出的线程在队列中等待。</li><li><code>newScheduledThreadPools</code>创建一个定长线程池，支持定时及周期性任务执行。</li><li><code>newSingleThreadExecutor</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序（FIFO，LIFO，优先级）执行。</li></ol></li></ul><h4 id="三、sleep-yield-join"><a href="#三、sleep-yield-join" class="headerlink" title="三、sleep(), yield(), join()"></a>三、<code>sleep()</code>, <code>yield()</code>, <code>join()</code></h4><ul><li><p><code>Thread.sleep(long millis)</code>：用来暂停当前线程的执行，会通知线程调度器把当前线程在指定的时间周期内置为wait状态。当wait时间结束，线程重新变为<code>Runnable</code>并等待CPU的再次调度，所以<code>sleep</code>的实际时间取决于线程调度器，这是由操作系统来完成的。</p></li><li><p><code>Thread.join()</code>：很多情况下，主线程生成并启动了子线程，如果子线程需要大量的耗时的运算，主线程往往将于子线程之前结束，但如果主线程处理完其他的事物后，需要用到子线程的处理结果，也就是主线程等待子线程完成之后再结束，这个时候就用到<code>join()</code>方法了。</p></li><li><p><code>Thread.yield()</code>：暂停当前线程， 以便其他线程有机会执行。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(), <span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;mian--&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// 暂停该线程</span></span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">// 等待thread线程执行完成再执行</span></span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="四、线程的状态"><a href="#四、线程的状态" class="headerlink" title="四、线程的状态"></a>四、线程的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                    +--------------&gt;TIMED_WAITED---------------------+</span><br><span class="line">                    |Thread.sleep(Long)                              | Object.notify()    </span><br><span class="line">                    |Object.wait(Long)                               | Object.notifyAll()</span><br><span class="line">                    |Thread.join(Long)                               | LockSupport.unpark(Thread)</span><br><span class="line">                    |LockSupport.parkNanos()                         |</span><br><span class="line">                    |LockSupport.parkUntil()                         |</span><br><span class="line">                    |                 (RUNNABLE)                     v</span><br><span class="line">                   +-----------------------------------------------------+</span><br><span class="line">                   |                                                     |</span><br><span class="line">                   |  +-------+     system scheduling       +---------+  |           +-----------+</span><br><span class="line">+-----+            |  |       |  -------------------------&gt; |         |  |           |           |</span><br><span class="line">| NEW |--start()--&gt;|  | READY |                             | RUNNING |  |----------&gt;| TEMINATED |  </span><br><span class="line">+-----+            |  |       | &lt;----Thread.yield---------- |         |  |           |           |</span><br><span class="line">                   |  +-------+                             + --------+  |           +-----------|</span><br><span class="line">                   +-----------------------------------------------------+</span><br><span class="line">                    |   |Ojbect.wait()               Ojbect.notify()  ^ ^</span><br><span class="line">                    |   |Thread.join()             Ojbect.notifyAll() | |获取到锁</span><br><span class="line">                    |   |LocKSupport.park() LocKSupport.unpark(Thread)| |</span><br><span class="line">                    |   +--------------------&gt;WAIT--------------------+ |</span><br><span class="line">                    +-----------------------&gt;BLOCKED--------------------+</span><br><span class="line">                     等待进入Synchronized方法（块）</span><br></pre></td></tr></table></figure><ul><li>NEW(初始)：通过实现Runnable或继承Thread得到一个线程类，new一个实例出来，线程就进入了初始状态。</li><li>READY(就绪)：线程进入就绪状态说明该线程有了运行资格，可以通过系统的调度进入运行状态。<ol><li>调用线程的<code>start()</code>方法，该线程就进入了就绪状态。</li><li>线程的<code>sleep()</code>方法结束，或者其他方法<code>join()</code>结束，等待用户输入结束，或者某个线程拿到锁，线程进入就绪状态。</li><li>调用当前线程<code>yield()</code>方法，当前线程进入就绪状态。</li><li>锁池中的对象拿到对象锁之后，进入就绪状态。</li></ol></li><li>RUNNING(运行)：线程调度程序从可运行池中选择一个线程作为当前线程所处的状态。这也是线程进入运行状态的唯一一种方式。</li><li>BOLCKED(阻塞)：组赛状态是线程阻塞进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</li><li>WAIT(等待)：这种状态的线程不会被分配CPU执行时间，它们要显式的被唤醒，否则会进入无期限等待的状态。</li><li>TIMED_WAITING(超时等待)：这种状态的线程不会被分配CPU执行时间 ，不过它们无须被唤醒，在达到一定时间它们会被自动唤醒。</li><li>TEMINATED(终止)：线程的run方法或者主线程的main方法执行完成之后，这个线程就终止了。终止的线程不能复生。如果强行调用<code>start()</code>方法执行线程，会抛出<code>java.lang.IllegalThreadStateException</code>异常。</li></ul><h4 id="五、synchronized关键字"><a href="#五、synchronized关键字" class="headerlink" title="五、synchronized关键字"></a>五、<code>synchronized</code>关键字</h4><p>​ 既可以保证线程的原子性，又可以保证线程的可见性</p><p>​ 先看下面这个程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kangfawei.item01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         UnSyncDemo unSyncDemo = <span class="keyword">new</span> UnSyncDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(unSyncDemo);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(unSyncDemo.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnSyncDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面程序中开启了10个线程，每个线程都累加了1000次，结果应该时10*1000=10000，但是多次执行下来发现结果都是比10000小，有些甚至少很多。原因就是每个线程都有不同的栈空间，一个线程将count中的数据拿到之间的栈空间执行但还没有执行完成的时候，另外一个线程拿到同样结果的count在自己的空间中执行，这样就会导致之前的情况发生。</p><p>设想如果多个线程依次执行的时候就不会产生上面的那种情况。java中的<code>synchronized</code>关键字就是让每个线程依次执行，但是同时，<code>synchronized</code>关键字由于每个线程依次执行的原因会很明显的降低程序的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kangfawei.item01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncDemo syncDemo = <span class="keyword">new</span> SyncDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(syncDemo);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(syncDemo.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 增加的代码块加锁</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时不管执行多少次，执行结果都会是10000，因为前面执行的线程会占用对象锁，等待执行完成之后才会释放锁，其他线程抢到锁的时候继续占有锁，剩下的线程继续等待，直到所有线程执行完毕。这样就不会产生多个线程拿到同样的count执行。</p><ul><li><p>锁的对象：</p><ul><li>实例方法中：<code>public synchronized void mothed()</code>实例方法中锁的对象是该类的实例对象</li><li>静态方法中：<code>public static synchronized void methor()</code>静态方法中所得对象是类对象</li><li>实例对象：<code>synchronized(this) &#123;&#125;</code> 同步代码块，锁住的是该类的实例对象</li><li>class对象：<code>synchronized(SyncDemo.class) &#123;&#125;</code>同步代码块，锁住的是该类的对象</li><li>任意Object：<code>synchronized(obj) &#123;&#125;</code>任意对象可以作为同步代码块的锁（谨慎使用String、Integer等包装类）</li></ul></li><li><p>可重入</p><blockquote><p>同一个锁程中，线程可以多次获取同一把锁。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一，当计数器为零的时候释放锁。</p></blockquote></li><li><p>锁升级</p><p><code>synchronized</code>锁可以升级，无锁–&gt;偏向锁–&gt;自旋锁–&gt;OS锁</p><p>没有线程访问同步方法/同步代码块的时候，是没有锁的。当只有一个线程访问的时候，由无锁升级为偏向锁，当锁发现访问的还是同一个线程的时候，默认放行。继续增加线程的时候，锁会升级为自旋锁，线程会循环获取锁，如果线程多次循环还是无法获取到锁，或者等待线程过多，那么锁就会升级为最终的OS锁，线程会进入OS的就绪队列中，直到锁被释放后去抢到锁。</p><p>自旋锁：效率高，但是自旋过程会占用CPU资源，所以线程数比较小、时间比较短的情况下适合使用。</p><p>重量级锁：不占用CPU资源，但是效率比较低</p></li></ul><h4 id="六、volatile关键字"><a href="#六、volatile关键字" class="headerlink" title="六、volatile关键字"></a>六、<code>volatile</code>关键字</h4><ul><li><p>保证线程可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileTest test = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test, <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2s过后更改flag的值，让线程停止运行</span></span><br><span class="line">        test.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 此处volatile必须要加，如果不加会导致更改flag变量此处接收不到</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">            <span class="comment">// 通过更改变量flag让线程停止</span></span><br><span class="line">            <span class="comment">// 如果不加volatile线程会一直向下运行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>volatile</code>关键字每次读取变量前必须先从主内存刷新最新的值。</p></li><li><p><code>volatile</code>关键字写入后必须同步会主内存中</p></li></ul><p>由于上面两条规则，所以<code>volatile</code>可以保证每次看到的都会是最新值，从而保证可见性。但是<code>volatile</code>不保证线程的原子性，所以不可以保证线程的安全性。</p></li><li><p>禁止指令重排序</p><p>在一段代码的运行过程中，对于一些没有依赖关系的代码，编译器和处理器为了提高效率，可能会产生一些顺序的改变，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;  <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，代码1跟2没有依赖关系，所以处理器执行过程中可能会先执行2，然后再执行1。在单线程中，这种指令重排序不会产生任何问题，但是再多线程的情况下，可能就会有一些问题出现。如在下面的懒加载单例模式中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在懒加载的单例模式中，上面的例子几乎可以说是完美的，一般情况下不会由问题产生，但这个问题并不是百分百完美的，在一些并发量极大的情况下，会发生instance不为null，但是变量没有被初始化。</p><p><code>instance == new Singleton()</code>这个赋值语句并不是一个原子操作，它可以分为三部分执行：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>设置instance执行刚分配的内存地址</li></ol><p>当发生指令重排序的时候，第二步跟第三步调换位置，instance指向分配好的内存空间的时候，这个内存空间没有被初始化。如果此时另外一个线程进入，就会直接返回没有被初始化内存空间的对象。解决这个问题就需要将声明加上<code>volatile</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br></pre></td></tr></table></figure></li></ul></div><div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div><div class="investment-container"><div class="investment-header"><div class="investment-title-1"><div class="on">相关文章</div><div>评论</div><div>分享</div></div><div class="investment-title-2"><span><a id="totop-post-page">返回顶部</a> <a href="/2020/08/23/Java%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/" title="Java对象初始化与清理" rel="next">下一篇&raquo;</a></span></div></div><div class="investment-content"><div class="investment-content-list"><div class="relate-post"><ul><li><div class="relate-post-text"><a class="relate-post-title" href="/2020/08/23/Java%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/" title="Java对象初始化与清理">Java对象初始化与清理</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 八月 23日, 2020</p><p class="relate-post-content">关于对象初始化 Java沿用C++中通过给一个类提供构造器来初始化对象。 构造器方法的名称与类名称一致，可以让调用者明确知道使用的是什么类型的对象，同时可以避免该方法与其成员方法名称一致。 Java创建一个类至少需要提供一个构造器...</p></div><div class="relate-post-cover"><a href="/2020/08/23/Java%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/" title="Java对象初始化与清理"><img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Java对象初始化与清理"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/2020/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/" title="设计模式学习（(Design Patterns)）">设计模式学习（(Design Patterns)）</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 八月 12日, 2020</p><p class="relate-post-content">一、单例模式(Singleton)概念一个类只有一个实例，且该类能自行创建这种实例。 特点 只有一个实例 能自行创建实例 对外提供一个能访问该实例的全局访问点 应用 饿汉式 12345678910public class Singl...</p></div><div class="relate-post-cover"><a href="/2020/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/" title="设计模式学习（(Design Patterns)）"><img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="设计模式学习（(Design Patterns)）"></a></div></li></ul></div></div><div class="investment-content-list"><div class="layout-comment"><div class="config-info">Please check the parameter of <b>comment</b> in config.yml of hexo-theme-Annie!</div></div></div><div class="investment-content-list"><div class="layout-share"><div class="social-share"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></div></div></div></div></div></div><script src="/plugin/clipboard/clipboard.js"></script><script>// Copy code !
	    function preprocessing() {
	        $("#article-content .highlight").each(function() {
	            $(this).wrap('<div id="post-code"></div>');
	        })

	        $("#article-content #post-code").each(function() {
	            $(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>');
	        })

	        $("#article-content .copy-nav").each(function() {
	            let languageClass = $(this).next().attr('class'),
	                language = ((languageClass.length > 9) && (languageClass != null)) ? languageClass.substr(10) : "none"; //why 9? Need to check language?

	            $(this).find('.code-language').text(language);
	            $(this).append('<span class="copy-btn icon-paste"></span>');
	        });
	    }

		function copy() {
		    $('#article-content #post-code').each(function(i) {
		        let codeCopyId = 'codeCopy-' + i;

		        let codeNode = $(this).find('.code'),
		            copyButton = $(this).find('.copy-btn');

		        codeNode.attr('id', codeCopyId);
		        copyButton.attr('data-clipboard-target-id', codeCopyId);
		    })
   
			let clipboard = new ClipboardJS('.copy-btn', {
					target: function(trigger) {
						return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
					}
		      	});

			//pure js
			function showTooltip(elem, msg) {		   
				elem.setAttribute('aria-label', msg);
				elem.setAttribute('class', 'copy-btn icon-clipboard1');
				setTimeout(function() {
					elem.setAttribute('class', 'copy-btn icon-paste');
				}, 2000);
			}

			clipboard.on('success', function(e) {
			    e.clearSelection();
			    console.info('Action:', e.action);		   
			    console.info('Trigger:', e.trigger);
			    showTooltip(e.trigger, 'Copied!');   
			});
			
			clipboard.on('error', function(e) {
			    console.error('Action:', e.action);
			    console.error('Trigger:', e.trigger);
			});
		}
		
		(function copyCode(){
			if ($('.layout-post').length) {
			    preprocessing();
			    copy();
			} 
		})();</script><link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css"><script src="/plugin/fancybox/jquery.fancybox.js"></script><script type="text/javascript">(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();</script></main><footer><div id="navigation-show"><ul id="global-nav"><li class="menu-home"><a href="/" class="menu-item-home" target="_blank">主页</a></li><li class="menu-archive"><a href="/archives" class="menu-item-archive" target="_blank">归档</a></li><li class="menu-categories"><a href="/categories" class="menu-item-categories" target="_blank">分类</a></li><li class="menu-tags"><a href="/tags" class="menu-item-tags" target="_blank">标签</a></li><li class="menu-about"><a href="/about" class="menu-item-about" target="_blank">关于</a></li><li class="menu-gallery"><a href="/gallery" class="menu-item-gallery" target="_blank">相册</a></li></ul></div><div class="copyright"><p>&copy;2017 - 2020, content by Sariay. All Rights Reserved. <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.</p><p><a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> <a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a></p></div></footer><script src="/plugin/motto/motto.js"></script><script type="text/javascript">(function motto(){
			let mottoText = getMingYanContent().split('</br> - </br>'),
			
			mottoTextContent = mottoText[0]?mottoText[0]:'请刷新...',
			
			mottoTextFrom = mottoText[1]?mottoText[1]:'one/一个';
			
			mottoTextContent = mottoTextContent.trim().substring(0, 100);
		
			$("#motto-content").html( mottoTextContent);
			$("#motto-author").html( mottoTextFrom  );
		})();</script><div id="totop"><span class="icon-circle-up"></span></div><script src="/plugin/chinese/chinese.js"></script><script src="/plugin/imagelazyloader/yall.min.js"></script><script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script><script src="/plugin/nicescroll/jquery.nicescroll.js"></script><script src="/plugin/resizediv/resizediv.js"></script><script src="/js/main.js"></script></body></html>